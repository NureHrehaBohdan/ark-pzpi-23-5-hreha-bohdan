МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
До лабораторної роботи №4
з дисципліни «Аналіз та рефакторинг коду»













Виконав: 										      Прийняв:
ст. гр. ПЗПІ-23-5 ст. 						       викладач катедри ПІ
Грега Богдан 							Сокорчук Ігор Петрович









Харків 2025
1 ІСТОРІЯ ЗМІН

№ДатаВерсія звітуОпис змін та виправлень121.120.1Створено звіт

2 ЗАВДАННЯ

     Ознайомитися з процесом проєктування та розробки програмного забезпечення IoT-клієнта, призначеного для збору, обробки та передачі даних з пристроїв Інтернету речей до серверної частини системи. Розглянути принципи побудови архітектури IoT-клієнта з урахуванням його взаємодії з сервером, використання мережевих протоколів обміну даними та забезпечення керування підключеними пристроями.
     Отримати практичні навички розробки бізнес логіки IoT-клієнта, зокрема реалізації зчитування даних із сенсорів, їх обробки та надсилання на сервер за допомогою протоколів MQTT та HTTP. Розробити функції налаштування IoT-клієнта, включаючи конфігурацію мережевих параметрів, керування режимами роботи та відновлення параметрів за замовчуванням. Створити UML-діаграми прецедентів і діяльності, що відображають основні сценарії роботи IoT-клієнта, а також виконати перевірку працездатності реалізованого програмного забезпечення.

3 ОПИС ВИКОНАНОЇ РОБОТИ

     Архітектура IoT клієнта спроектована з урахуванням модульності, масштабованості та надійності. Система складається з двох основних компонентів: сенсорної підсистеми та агрегатора погодних даних. Сенсори безперервно вимірюють ключові параметри навколишнього середовища, такі як температура, вологість, швидкість вітру та атмосферний тиск. Передача цих даних здійснюється через протокол MQTT, який обрано завдяки його легкості, підтримці підписки на теми та гарантованій доставці повідомлень з QoS. Вибір MQTT забезпечує низьку затримку та зменшує навантаження на мережу, що є критично важливим для IoT-рішень. 
     Для демонстрації взаємодії користувача та системи була створена UML-діаграма прецедентів (див. Рис. 1). На ній відображено ключові сценарії, такі як надсилання даних сенсорами, агрегація даних, оновлення конфігурації агрегатора, відновлення налаштувань за замовчуванням. Ця діаграма дозволяє наочно оцінити функціональні можливості IoT-клієнта та взаємодію між сенсорами, агрегатором і адміністратором.

Рисунок 1 — Діаграма прецедентів
      
     Агрегатор приймає дані від сенсорів та обробляє їх у кілька етапів. Спершу дані проходять перевірку на валідність (додаток В.1), що дозволяє відсіювати некоректні або пошкоджені повідомлення. Після цього показники зберігаються у внутрішній пам’яті до досягнення встановленого інтервалу–відправки. Коли інтервалу–відправки досягає заданого часу (за замовчуванням 30 секунд, але його можна змінювати динамічно), агрегатор обчислює середні значення кожного параметру та визначає їхні індивідуальні статуси за встановленими порогами (додаток В.2). Статуси визначаються за категоріями «GOOD», «WARNING» та «BAD», що дозволяє одразу оцінити стан навколишнього середовища. На основі цих індивідуальних статусів агрегатор формує загальний стан системи («EXCELLENT», «GOOD», «WARNING», «BAD») та публікує агреговані дані через MQTT, одночасно надсилаючи їх на серверну частину за допомогою REST API. Всі ці процеси ілюструє UML-діаграма діяльності (додаток Б.1), де показано логіку від прийому даних сенсором до публікації агрегованого стану.
     Система надає адміністратору можливість змінювати конфігурацію агрегатора в реальному часі. Це включає батч-інтервал, пороги для всіх основних параметрів, а також URL REST API для інтеграції з серверною частиною. Реалізована також функція відновлення налаштувань за замовчуванням, яка дозволяє швидко повернути всі параметри до стандартних значень, включно з порогами, батч-інтервалом і REST URL, що є важливим для швидкого реагування у випадку некоректних налаштувань або потреби скинути конфігурацію. Ця функціональність підтримується через окрему MQTT-тему, що дозволяє надсилати команду RESET, після чого агрегатор автоматично відновлює всі параметри. Логіка зміни конфігурації та скидання налаштувань показана на UML-діаграмі діяльності (додаток Б.1), а приклади реалізації бізнес-логіки наведено у Додатку В.
     Комунікаційна підсистема побудована таким чином, щоб забезпечити гнучке управління потоками даних. MQTT використовується для безпосередньої передачі сенсорних даних до агрегатора та отримання конфігураційних змін від адміністратора. REST API забезпечує довготривале збереження агрегованих даних на сервері та дозволяє інтегрувати IoT-клієнт із іншими системами моніторингу. Завдяки цьому поєднанню протоколів досягається баланс між швидкістю обміну даними та сумісністю з бекенд-системою.
     Бізнес-логіка агрегатора реалізує всі критичні операції, необхідні для обробки даних сенсорів, включаючи їхню агрегацію, обчислення середніх значень, оцінку статусів і формування загального стану системи. Під час розробки було передбачено обробку виняткових ситуацій, таких як некоректні дані або проблеми з мережею, що дозволяє забезпечити стабільність роботи системи навіть у разі непередбачених умов. Код, який реалізує цю логіку, а також функції конфігурування та скидання налаштувань, наведено у Додатку В.
     Таким чином, запропонована архітектура IoT-клієнта забезпечує надійне збирання, обробку та передачу даних від сенсорів, дозволяє адміністратору динамічно управляти конфігурацією агрегатора, а також гарантує можливість відновлення системи до стандартного стану за необхідності. UML-діаграми ілюструють структуру та логіку системи, тоді як Додаток В демонструє конкретну реалізацію бізнес-логіки та функцій налаштування.
     
     
     

4 ВИСНОВОК
     
     У ході лабораторної роботи було розроблено та проаналізовано архітектуру IoT-клієнта для моніторингу погодних параметрів. Було обрано протокол MQTT для оперативної передачі даних від сенсорів до агрегатора, а REST API — для збереження та інтеграції агрегованої інформації на сервері. Реалізована бізнес-логіка забезпечує перевірку достовірності даних, їх агрегацію, оцінку стану системи за заданими порогами та публікацію результатів у реальному часі.
     Система дозволяє адміністратору динамічно змінювати налаштування, включаючи батч-інтервал, пороги параметрів та URL серверної частини, а також виконувати скидання налаштувань до значень за замовчуванням. UML-діаграми прецедентів та діяльності  наочно демонструють основні сценарії використання та логіку обробки даних.
     Розроблене рішення показало ефективність у зборі та обробці даних, стабільність роботи навіть у разі некоректних повідомлень та гнучкість у налаштуванні конфігурацій. Така архітектура забезпечує надійність, масштабованість та готовність до інтеграції в більші IoT-системи.

5 ВИКОРИСТАНІ ДЖЕРЕЛА

      1. PlantUML – офіційна документація. URL: https://plantuml.com/ (дата звернення: 20.12.2025)
      2. MQTT – офіційна специфікація. URL: http://mqtt.org/  (дата звернення: 21.12.2025)
     
     

ДОДАТОК А
Посилання на відео: https://youtu.be/Lj_oD8gnG9g 
00:00 Структура IoT клієнту 
00:31 Огляд коду агрегатору
02:36 Тестування налаштувань IoT клієнту




ДОДАТОК Б
Графічні матеріали
      

Рисунок Б.1 – Діаграма діяльності

ДОДАТОК В
Фрагменти коду

В.1 Обробка отриманих даних від сенсорів
 1  def on_message(self, client, userdata, msg):
 2      """Обробляє повідомлення від датчиків"""
 3      try:
 4          payload = json.loads(msg.payload.decode())
 5          sensor_id = payload.get("sensor_id")
 6          
 7          # Накопичення
 8          self.sensor_readings[sensor_id].append(payload)
 9          
10          print(
11              f"[{self.aggregator_id}] Sensor {sensor_id}: "
12              f"T={payload['temperature']} "
13              f"H={payload['humidity']} "
14              f"W={payload['wind_speed']}"
15          )
16          
17          # Перевірка інтервалу
18          now = time.time()
19          if now - self.last_publish_time >= self.BATCH_INTERVAL:
20              self.aggregate_and_publish()
21              self.last_publish_time = now
22      
23      except Exception as e:
24          print(f"[{self.aggregator_id}] Sensor message error: {e}")

В.2 Функція агрегації та визначення статусу
 1  def get_range_status(self, value, thresholds):
 2      """Визначає статус для параметрів з діапазоном"""
 3      opt_min, opt_max = thresholds["optimal"]
 4      warn_min, warn_max = thresholds["warning"]
 5      
 6      if opt_min <= value <= opt_max:
 7          return "GOOD", 100
 8      elif warn_min <= value <= warn_max:
 9          return "WARNING", 70
10      else:
11          return "BAD", 0
12  
13  def get_wind_status(self, wind):
14      """Визначає статус для вітру"""
15      if wind <= self.wind_thresholds["optimal"]:
16          return "GOOD", 100
17      elif wind <= self.wind_thresholds["warning"]:
18          return "WARNING", 70
19      else:
20          return "BAD", 0
21  
22  def aggregate_and_publish(self):
23      """Агрегує накопленні дані та публікує результат"""
24      if not self.sensor_readings:
25          return
26      
27      print(f"[{self.aggregator_id}] ?? Aggregating...")
28      
29      # Збір даних
30      temps, winds, hums, press = [], [], [], []
31      
32      for readings in self.sensor_readings.values():
33          for r in readings:
34              temps.append(r["temperature"])
35              winds.append(r["wind_speed"])
36              hums.append(r["humidity"])
37              press.append(r["pressure"])
38      
39      # Розрахунок середніх
40      avg_temp = round(mean(temps), 1)
41      avg_wind = round(mean(winds), 1)
42      avg_hum = round(mean(hums), 1)
43      avg_press = round(mean(press), 1)
44      
45      # Визначення статусів
46      temp_status, ts = self.get_range_status(avg_temp, self.temperature_thresholds)
47      wind_status, ws = self.get_wind_status(avg_wind)
48      hum_status, hs = self.get_range_status(avg_hum, self.humidity_thresholds)
49      press_status, ps = self.get_range_status(avg_press, self.pressure_thresholds)
50      
51      # Overall score
52      overall_score = (ts + ws + hs + ps) / 4
53      overall_status = (
54          "EXCELLENT" if overall_score >= 95 else
55          "GOOD" if overall_score >= 70 else
56          "WARNING" if overall_score >= 50 else
57          "BAD"
58      )
59      
60      # Результат
61      result = {
62          "aggregator_id": self.aggregator_id,
63          "timestamp": datetime.now().isoformat(),
64          "overall_status": overall_status,
65          "temperature": {"average": avg_temp, "status": temp_status},
66          "wind_speed": {"average": avg_wind, "status": wind_status},
67          "humidity": {"average": avg_hum, "status": hum_status},
68          "pressure": {"average": avg_press, "status": press_status},
69          "sensors_count": len(self.sensor_readings),
70          "sensors": list(self.sensor_readings.keys())
71      }
72      
73      # Публікація
74      self.client.publish(OUTPUT_TOPIC, json.dumps(result), qos=1)
75      print(f"[{self.aggregator_id}] Published: {overall_status}")
76      
77      self.send_to_rest_api(result)
78      self.sensor_readings.clear()
