МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
До лабораторної роботи №3
з дисципліни «Аналіз та рефакторинг коду»













Виконав: 										      Прийняв:
ст. гр. ПЗПІ-23-5 ст. 						       викладач катедри ПІ
Грега Богдан 							Сокорчук Ігор Петрович









Харків 2025
1 ІСТОРІЯ ЗМІН

№ДатаВерсія звітуОпис змін та виправлень120.120.1Створено звіт

2 ЗАВДАННЯ

     Ознайомитися з процесом розробки бізнес логіки та функцій адміністрування серверної частини програмної системи. Отримати практичні навички реалізації бізнес логіки, функцій адміністрування, створення UML-діаграм діяльності та взаємодії, а також перевірки (тестування) роботи серверної частини.
     

3 ОПИС ВИКОНАНОЇ РОБОТИ
     3.1 Адміністрування користувачів та маршрутів
     
     Було реалізовано можливість адміністратору керувати користувачами та маршрутами у системі. Адміністратор може додавати нових користувачів, редагувати існуючих, призначати права доступу, а також створювати, змінювати та видаляти маршрути. Всі дії виконуються через сервіси, що взаємодіють із репозиторіями та моделями даних, забезпечуючи цілісність і консистентність інформації. 
     Адміністратор може створювати бекапи бази даних, сервер реалізує даний функціонал за допомогою BackipService який взаємодіє з репозиторіями та зберігає копії даних у визначеному форматі, та методу createBackup() (додаток В.1). Також адміністратор може переглядати видаляти бекапи.
     Детальна взаємодія між шарами системи під час адміністрування показана на діаграмі взаємодії (додаток Б.1).
     
     3.2 Прогноз навантаження (EWMA та погодні корекції)
     
     Для аналітики було реалізовано прогноз навантаження на основі експоненційного згладженого середнього (EWMA) за формулою:
     St? = ? ? Xt ?+ (1 ? ?) ? St?1?
де  	St ? – згладжене значення на момент часу t (EWMA);
     Xt ? – фактичне значення навантаження (кількість сесій) на момент часу;
     ? – коефіцієнт згладжування.
     При цьому до формули може бути доданий погодний коефіціент що має наступну формулу:
     Wt?= 1 + 0.03 ? (T ? Topt?) ? 0.05 ? V ? 0.01 ? H
де	T – температура;
     V — швидкість вітру;
     H — вологість;
     Метод використовує історичні дані про тренувальні сесії та обчислює згладжене значення, яке потім коригується з урахуванням погодних умов через коефіцієнт впливу температури, вітру та вологості. Це дозволяє оцінити очікувану активність користувачів та виявити тренди. 
     Реалізацію знаходження  можна знайти у сервісі AnalyticsService ключовими методами є forecastLoad() (додаток В.2), який формує остаточний прогноз, використовуючи допоміжні методи ewma() (додаток В.3)  для обчислення експоненційно зваженого середнього та weatherFactor() (додаток В.4),  для врахування впливу погодних умов, при цьому вплив коефіцієнту обмежений від 0.5 до 1.3. Метод chooseAlpha() (додаток В.5), обирає оптимальний коефіцієнт згладжування alpha залежно від середньої кількості сесій, що дозволяє адаптувати прогноз під обсяг даних. 
     Детальна взаємодія між шарами системи під час виконання цього процесу показана на діаграмі взаємодії (додаток Б.2), а для відображення  відображення послідовності виконання була створена діаграма послідовності (додаток Б.3)
     
     3.3 Статистика середньої активності на маршруті
     
     Розроблено просту статистику середньої активності користувачів для кожного маршруту. Функція обчислює середню кількість сесій на маршруті, що дозволяє виявити найпопулярніші маршрути та планувати ресурси. Для реалізації використовується метод getAverageActivityPerRoute() (додаток В.6), який виконує запит до репозиторію маршрутів, отримує дані по середній кількості сесій та округлює результат до двох знаків після коми для зручності відображення. Послідовність збору даних і обчислень представлена на діаграмі послідовності (Додаток Б.4), а приклад реалізації наведено в Додатку В. Ця статистика дозволяє аналізувати активність користувачів на різних маршрутах і приймати рішення щодо оптимізації маршрутів або ресурсів.
     
     3.4 Часова статистика сесій по годинах доби
     
     Ще однією корисною статистикою є розподіл кількості тренувальних сесій за годинами доби. Це дає змогу побачити пікові періоди активності користувачів та використовувати дані для графіків або прогнозів. Метод getHourlyActivity() (додаток В.7) отримує дані по годинах із репозиторію тренувальних сесій та формує список об’єктів HourlyActivityPoint, де вказано годину та кількість сесій. Такий підхід дозволяє швидко будувати графіки активності та виявляти тенденції використання маршрутів протягом дня. Послідовність збору даних і обчислень представлена на діаграмі послідовності (додаток Б.6). Ця інформація може бути використана для планування тренувальних заходів або адаптації прогнозів навантаження на системі.


4 ВИСНОВОК
     
     У ході виконання роботи було розроблено ключові функції адміністрування та аналітики серверної частини системи. Було реалізовано управління користувачами та маршрутами, включно з можливістю створення, редагування та видалення записів, а також функціонал створення та перегляду бекапів бази даних. 
     Для аналітики реалізовано прогноз навантаження на основі експоненційного зваженого середнього (EWMA) з урахуванням погодних умов, що дозволяє оцінювати очікувану активність користувачів та виявляти тренди.
     Крім того, були реалізовані статистичні функції, зокрема середня активність користувачів на маршрутах та розподіл сесій по годинах доби. Це дозволяє відстежувати популярність маршрутів, визначати пікові періоди активності та планувати ресурси ефективніше. Усі функції були реалізовані з урахуванням взаємодії між шарами системи, що забезпечує цілісність даних і стабільну роботу сервера. Використання UML-діаграм діяльності та взаємодії допомогло наочно представити логіку роботи системи та послідовність виконання ключових процесів, що полегшує підтримку та подальший розвиток програмного забезпечення.
     

5 ВИКОРИСТАНІ ДЖЕРЕЛА

      1. Spring Boot – офіційна документація. URL: https://spring.io/projects/spring-boot (дата звернення: 18.12.2025)
      2. Spring Data JPA – офіційна документація. URL: https://spring.io/projects/spring-data-jpa (дата звернення: 18.12.2025)
      3. PlantUML – офіційна документація. URL: https://plantuml.com/ (дата звернення: 20.12.2025)
      4. Wikipedia – Exponential moving average. URL: https://en.wikipedia.org/ wiki/Exponential_smoothing (дата звернення: 19.12.2025)

     
     

ДОДАТОК А
     Посилання на відео: https://youtu.be/dp9Rgo0Ji_o 
     00:00 Вступ
     00:35 Функції адміністрування
     01:12 Перегляд аналітичних функцій
     02:44 Функції бекапів
     03:13 Тестування




ДОДАТОК Б
Графічні матеріали


Рисунок Б.1 – Діаграмі взаємодії при створенні бекапу


Рисунок Б.2 — Діаграма взаємодії при знаходженні EWMA


Рисунок Б.3 –- Діаграма послідовності при знаходженні EWMA


Рисунок Б.4 –- Діаграма послідовності при знаходженні актвиності по маршрутам

Рисунок Б.5 – Діаграма послідовності при знаходженні погодинної активності 

ДОДАТОК В
Фрагменти коду

     В.1 Код методу createBackuр для створення бекапу бази даних
      1.  @Override
      2.  public ApiResponse<CreateBackupResponse> createBackup() {
      3.      try {
      4.          Path backupPath = Path.of(backupDir);
      5.          if (!Files.exists(backupPath)) {
      6.              Files.createDirectories(backupPath);
      7.          }
      8.
      9.          String filename = "backup_" + LocalDateTime.now()
      10.                 .format(DateTimeFormatter.ofPattern("yyyy-MM-dd_HH-mm")) + ".dump";
      11.         String filePath = backupDir + "/" + filename;
      12.
      13.         ProcessBuilder pb = new ProcessBuilder(
      14.                 "F:\\postgre\\bin\\pg_dump.exe",
      15.                 "-Fc",
      16.                 "-U", dbUser,
      17.                 "-f", filePath,
      18.                 extractDbName(dbUrl)
      19.         );
      20.         pb.environment().put("PGPASSWORD", dbPassword);
      21.
      22.         Process process = pb.start();
      23.         int exitCode = process.waitFor();
      24.
      25.         if (exitCode != 0) {
      26.             throw new RuntimeException("Backup failed");
      27.         }
      28.
      29.         long size = Files.size(Path.of(filePath)) / 1024;
      30.         return new ApiResponse<>(true, "Backup created", new CreateBackupResponse(filename, backupDir , size));
      31.
      32.     } catch (Exception e) {
      33.         return new ApiResponse<>(false, "Error creating backup: " + e.getMessage(), null);
      34.     }
      35. }

     В.2 Метод forecastLoad
      1.  public LoadForecastResponse forecastLoad() {
      2.      List<LoadPoint> points = trainingRepo.getHourlyLoad().stream()
      3.              .map(r -> new LoadPoint(
      4.                      ((java.sql.Timestamp) r[0]).toLocalDateTime(),
      5.                      ((Number) r[1]).longValue()
      6.              ))
      7.              .toList();
      8.
      9.      if (points.size() < 2) {
      10.         throw new IllegalStateException("Not enough data for forecast");
      11.     }
      12.
      13.     double alpha = chooseAlpha(points);
      14.     double ewmaForecast = ewma(points, alpha);
      15.
      16.     WeatherData weather = weatherRepo.getLatest();
      17.     double adjusted = ewmaForecast * weatherFactor(weather);
      18.
      19.     long current = points.getLast().sessions();
      20.     double trend = adjusted - current;
      21.
      22.     return new LoadForecastResponse(
      23.             current,
      24.             ewmaForecast,
      25.             adjusted,
      26.             trend
      27.     );
      28. }
      
     В.3 Метод ewma
      1.  private double ewma(List<LoadPoint> points, double alpha) {
      2.      double smoothed = points.getFirst().sessions();
      3.      for (int i = 1; i < points.size(); i++) {
      4.          smoothed = alpha * points.get(i).sessions() + (1 - alpha) * smoothed;
      5.      }
      6.      return smoothed;
      7.  }
      
     В.4 Метод weatherFactor
      1.  private double weatherFactor(WeatherData w) {
      2.      double temperature = w.getTemperature().doubleValue();
      3.      double windSpeed = w.getWindSpeed().doubleValue();
      4.      double humidity = w.getHumidity().doubleValue();
      5.
      6.      double factor =
      7.              1
      8.              + 0.03 * (temperature - T_OPT)
      9.              - 0.05 * windSpeed
      10.             - 0.01 * humidity;
      11.
      12.     return Math.max(0.5, Math.min(factor, 1.3));
      13. }
      
     В.5 Метод chooseAlpha
      1.  private double chooseAlpha(List<LoadPoint> points) {
      2.      double avg = points.stream()
      3.              .mapToLong(LoadPoint::sessions)
      4.              .average()
      5.              .orElse(10);
      6.
      7.      if (avg < 10) return 0.4;
      8.      if (avg < 25) return 0.3;
      9.      return 0.2;
      10. }
      
     В.6 Метод getAverageActivityPerRoute()
      1.  public List<RouteActivityStat> getAverageActivityPerRoute() {
      2.      return routeRepository.getAverageActivityPerRoute()
      3.              .stream()
      4.              .map(r -> new RouteActivityStat(
      5.                      (String) r[0],
      6.                      Math.round(((Number) r[1]).doubleValue() * 100.0) / 100.0
      7.              ))
      8.              .toList();
      9.  }
      
     В.7 Метод getHourlyActivity()
      1.  public List<HourlyActivityPoint> getHourlyActivity() {
      2.
      3.      List<Object[]> raw = trainingRepo.getSessionsByHour();
      4.
      5.      return raw.stream()
      6.              .map(r -> new HourlyActivityPoint(
      7.                      ((Number) r[0]).intValue(),
      8.                      ((Number) r[1]).longValue()
      9.              ))
      10.             .toList();
      11. }
2


