МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
До практичного завдання №1
з дисципліни «Аналіз та рефакторинг коду»













Виконав:                                    Перевірив:
ст. гр. ПЗПІ-23-5              ст. викладач кафедри ПІ
Грега Богдан                    Сокорчук Ігор Петрович










Харків 2025
1. МЕТА РОБОТИ

     Сформувати розуміння важливості дотримання правил оформлення програмного коду мовою Java та вивчити основні рекомендації написання коду для забезпечення його якості, підтримуваності та ефективності. Навчитися застосовувати принципи code convention, рефакторингу, оптимізації та обробки помилок для підвищення читабельності, структурованості та зрозумілості програмного забезпечення.
     
2. ХІД РОБОТИ

     2.1 Стильові рекомендації
     
     Ефективність коду є одним з ключових факторів при розробці але дотримання єдиного стилю критично важливо для командної розробки, оскільки знижує плутанину та прискорює адаптацію нових розробників до проекту. Саме тому існують офіційні стандарти, такі як Google Java Style Guide, які визначають правила форматування, іменування, структуру коментарів та документацію
     Форматування коду у Java передбачає використання 4 пробілів для кожного рівня вкладеності. Це забезпечує портативність коду між різними редакторами. Довжина рядка не повинна перевищувати 100 символів, що дозволяє зручно працювати на стандартних моніторах. Розташування дужок слідує стилю керніган-ритчі де відкриваюча дужка залишається на тому ж рядку після оголошення, а закриваюча дужка розміщується на новому рядку або на тому ж рядку залежно від простоти виразу.
     Пробіли використовуються навколо бінарних операторів (=, +, -, *, /), після ключових слів (if, for, while). Це покращує сприйняття коду. Порожні рядки відокремлюють логічні секції коду, включаючи групи полів класу, конструктори, методи та вкладені класи.
     Приклад дотримання базових стильових рекомендацій:
      01: public boolean canAccess(boolean isActive, int accessLevel) {
      02:     // Метод з дужкою у стилі K&R та пробіли навколо операторів
      03:     if (isActive && accessLevel >= 3) { 
      04:         return true;    // 4 пробіли відступу
      05:     }
      06:     return false;
      07: }
     
2.2 Правила найменування змінних, функцій та класів

     Правильна номенклатура є основою читабельності коду. Імена повинні бути описовими, без скорочень (окрім загальноприйнятих), і вказувати на призначення змінної або функції.
     Правила найменування по типам:
     Класи названі іменниками у стилі PascalCase, де кожне слово починається з великої літери: User, PaymentService, DatabaseConnection, OrderValidator. Назва класу має чітко вказувати на його призначення. Методи та змінні іменуються у стилі camelCase з малої літери, при цьому методи часто починаються з дієслова: getUserName(), calculateTotalAmount(), isOrderValid(), processPayment(). Це робить зрозумілим, що метод виконує деяку дію.
     Приклад найменування класів, змінних та методів:
      01: public class User {			// клас PascalCase
      02:     private String userName;     	// змінна camelCase
      03:
      04:     public String getUserName() {	// метод camelCase
      05:         return userName;
      06:     }
      07: }
      
     Константи названі у стилі UPPER_SNAKE_CASE з використанням тільки великих літер і підкреслень: MAX_RETRY_ATTEMPTS, DEFAULT_TIMEOUT, INVALID_USER_MESSAGE. Константи слід оголошувати як static final для гарантії їх незмінності. 
     Приклад правильного іменування констант:
      01: public class MathConstants {
      02:     public static final double PI_VALUE = 3.14159;
      03:     public static final int MAX_BUFFER_SIZE = 1024;
      04: }
      
     Булеві змінні та методи часто префіксуються з is- або has-: isAdult, hasPermission, isProcessed, щоб явно вказати на логічний тип.
     Приклад правильного іменування констант:
      01: public class PermissionChecker {
      02:     private boolean hasAccess;           // булева змінна
      03:
      04:     public boolean isAllowed() {         // булевий метод
      05:         return hasAccess;
      06:     }
      07: }
      
     Пакети названі малими літерами у зворотному порядку доменів (com.company.users, org.example.payment), що полегшує уникання конфліктів імен у великих проектах.
     
2.3 Структура коду

     Правильна структура коду визначає архітектуру всього проекту. Java проекти організуються за пакетами, які відповідають функціональності системи. Це забезпечує модульність та полегшує навігацію.
     Структура директорій повинна відповідати структурі пакетів. Наприклад, клас com.company.users.User зберігається у файлі src/com/company/users/User.java. Кожен клас розміщується в окремому файлі з ім'ям, що збігається з іменем класу (public класи мають збігатися з іменем файлу).
     Порядок членів класу повинен бути логічним і послідовним. Спочатку оголошуються статичні константи, поля та ініціалізатори що можуть бути використані для логування чи виконані логіки при завантажені класа, потім йдуть екземплярні поля, далі конструктори, статичні методи й нарешті методи екземпляра. Методи відокремлюються порожніми рядками для читабельності.
     Структура класу:
      01: public class User {
      02:     // Статичні константи
      03:     private static final int ADULT_AGE = 18;
      04:     private static final String DEFAULT_ROLE = "USER";
      05:
      06:     // Статичний ініціалізатор
      07:     static {
      08:         System.out.println("Клас User завантажено у JVM");
      09:     }
      10:
      11:     // Екземплярні поля
      12:     private String name;
      13:     private int age;
      14:
      15:     // Конструктор
      16:     public User(String name, int age) {
      17:		this.name = name;
      18:		this.age = age;
      19:     }
      20:}
     

2.4 Принципи рефакторингу

     Рефакторинг — це процес покращення коду без зміни його зовнішньої поведінки. Це критично важливо для підтримки якості коду з часом та запобіганню його деградації.
     Екстракція методу (Extract Method) — виділення повторюваного або складного коду у окремий метод з осмисленою назвою. Це знижує складність методів і підвищує їх повторне використання.
     Приклад поганого коду:
      01: public void processOrder(Order order) {
      02:     if (order.getTotal() > 1000 && 
      03:         order.getCustomer().isPremium()) {
      04:         double discount = order.getTotal() * 0.15;
      05:         order.setTotal(order.getTotal() - discount);
      06:         System.out.println("Знижка застосована: " + discount);
      07:     }
      08: }
      
     З прикладу видно що даний код погано читаємий, а також його частини можуть бути використані в інших методах, скоротимо його за допомогою екстракції методів: 
      01: public void processOrder(Order order) {
      02:     if (shouldApplyDiscount(order)) {
      03:         applyPremiumDiscount(order);
      04:     }
      05: }
      
     Основний метод скоротили тепер можемо написати ті методи що ми винесли с основного методу: 
      07: private boolean shouldApplyDiscount(Order order) {
      08:     return order.getTotal() > 1000 &&
      09:            order.getCustomer().isPremium();
      10: }
      11: 
      12: private void applyPremiumDiscount(Order order) {
      13:     double discount = calculateDiscount(order.getTotal());
      14:     order.setTotal(order.getTotal() - discount);
      15:     logDiscountApplied(discount);
      16: }
      17: 
      18: private double calculateDiscount(double total) {
      19:     return total * 0.15;
      20: }
      
     Також завдяки екстракції методів ми зможемо використати код інших місцях що дозволить дотриматися принципу  DRY (Don't Repeat Yourself) що передбачає повторне використання коду уникаючи повторів.
     
2.5 Оптимізація продуктивності

     Основна оптимізація продуктивності в Java передбачає використання доречних класів. При використані правильних класів можна знизити алгоритмічну складність обравши оптимальні структури даних (масив vs ArrayList vs LinkedList).
     Також можна уникнути непотрібного об'єктного створення, а об'єкти, що часто використовуються, краще кешувати. Наприклад, StringBuild замість конкатенації рядків у циклах.
     Наприклад клас рядку у Java є незмінним і при кожній спробі його змінити створюється новий екземпляр класу:
      01: // Неефективно: створює нові String об'єкти в кожній ітерації
      02: String result = "";
      03: for (int i = 0; i < 10000; i++) {
      04:     result += i + ", ";
      05: }
     
     Клас StringBuilder в свою чергу є зміним та наприкінці може бути перетворений у рядок:
      01: // Ефективно: використовує StringBuilder
      02: StringBuilder result = new StringBuilder();
      03: for (int i = 0; i < 10000; i++) {
      04:     result.append(i).append(", ");
      05: }
      06: String finalResult = result.toString();
     
     Також використання примітивних класів пришвидшує роботу бо такі зміні не використовують автоматичного упакування/розпакування та зберігаються у стеку:
      01: // Неефективно
      02: Integer sum = 0;
      03: for (int i = 0; i < 1000000; i++) {
      04:     sum += i;
      05: }
      06: 
      07: // Ефективно
      08: int sum = 0;
      09: for (int i = 0; i < 1000000; i++) {
      10:     sum += i;
      11: }
      
     Також слід не забувати що Java мова для паралельного програмування але створення кожного окремого потоку займає ресурси (час та пам’ять). Якщо задач багато, буде велике навантаження на JVM, важко керувати життєвим циклом потоків і синхронізацією.
     Для уникнення цих проблем слід використовувати ExecutorService / пул потоків.
     

     Створимо приклад з п’ятьма потоками:
      01: ExecutorService executor = Executors.newFixedThreadPool(5); 
      02: 
      03: for (int i = 0; i < 10; i++) {
      04:     int taskId = i;
      05:     executor.submit(() -> doTask(taskId));
      06: }
      07: 
      08: executor.shutdown(); // після завершення задач закриваємо пул
      
     І хоч на такому малому прикладі різниця буде не помітна, але при великій кількості задач та довгому життєвому циклі програми це дасть значний приріст в ефективності а також зменшить об’єм написаного коду.
     
2.6 Обробка помилок

     Правильна обробка помилок є критично важливою для надійності системи. Java надає механізм виняток для обробки аномальних ситуацій.
     Типи виняток:
     Checked exceptions (Перевірені винятки) — винятки, які компілятор примушує обробляти (IOException, SQLException). Вони використовуються для очікуваних помилок, які програма може відновити.
     Unchecked exceptions (Неперевірені винятки) — винятки, які компілятор не примушує обробляти (NullPointerException, IllegalArgumentException). Вони зазвичай вказують на помилки програміста.
     Синтаксис доволі простий, у блоці try розміщуємо код що може викликати помилку, а у catch оброблюємо у разі її появи
      01: try {
      02:     int result = divide(10, 0); // викличе помилку
      04: } catch (IllegalArgumentException e) {
      05:     System.out.println("Сталася помилка: " + e.getMessage());
      06: }
     Також блок try може бути використаний з ресурсами для автоматичного їх закриття  у разі помилки:
      01: try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
      02:     String line = reader.readLine();
      03:     System.out.println("Перша стрічка: " + line);
      04: } catch (IOException e) {
      05:     System.out.println("Помилка читання файлу: " + e.getMessage());
      06: }
      
     І хоча на прикладі BufferedReader, try-with-resources  може здаватися не таким корисним, він може бути критично важливим при використанні бази даних щоб не забути закрити з'єднання.
     
2.7 Дотримання парадигм програмування

     Java в своїй основі побудована на принципах об’єктно-орієнтованого програмування (ООП).
     Фундамент ООП у Java складається з чотирьох ключових концепцій:
* Інкапсуляція — приховування внутрішньої реалізації через модифікатори доступу.
* Спадкування — повторне використання коду через ієрархію класів.
* Поліморфізм — можливість викликати однакові методи у різних об’єктів.
* Абстракція — виділення суттєвих характеристик без зайвих деталей.
     Для створення гнучкої та підтримуваної архітектури застосовують принципи SOLID:
     S — Single Responsibility: клас виконує лише одну роль.
     O — Open/Closed: розширюється через новий код, а не змінюється старий.
     L — Liskov Substitution: підкласи повністю замінюють базові класи.
     I — Interface Segregation: краще кілька маленьких інтерфейсів, ніж один великий.
     D — Dependency Inversion: залежність від абстракцій, а не реалізацій.
     
     Java 8+ також підтримує елементи функціонального програмування — лямбда-вирази, Streams та функціональні інтерфейси. Це дозволяє писати більш лаконічний, виразний та декларативний код.
     
2.8 Тестування та документування коду

     Тестування — важлива частина розробки, що дозволяє перевірити коректність роботи коду, уникнути регресій та підвищити якість програми. У Java найпоширенішим інструментом для модульного тестування є JUnit.
     JUnit — це стандартний фреймворк для модульного тестування в Java. Він дозволяє автоматично перевіряти роботу методів і класів, забезпечуючи стабільність та надійність програми. Тести JUnit виконуються окремо від основного коду та перевіряють очікувану поведінку за допомогою асерцій (assertEquals, assertTrue, тощо).
      01: class CalculatorTest {
      02:
      03:     @Test
      04:     void add_shouldReturnCorrectSum() {
      05:         Calculator c = new Calculator();
      06:         assertEquals(5, c.add(2, 3));
      07:     }
      08: }
     
     У Java стандартом документації є вбудована система Javadoc, що дозволяє створювати документацію прямо з коментарів у коді. Це дозволяє описувати класи, методи, параметри та повернені значення так, щоб інші розробники могли швидко зрозуміти призначення коду.
     Використовуються спеціальні теги:
     @param — опис параметра
     @return — що повертає метод
     @throws — які винятки може кинути
     @author — автор
     @version — версія
     Приклад написання документації:
      01: /**
      02:  * Клас Calculator виконує базові арифметичні операції.
      03:  */
      04: public class Calculator {
      05:
      06:     /**
      07:      * Додає два числа.
      08:      *
      09:      * @param a перше число
      10:      * @param b друге число
      11:      * @return сума чисел a і b
      12:      */
      13:     public int add(int a, int b) {
      14:         return a + b;
      15:     }
      16: }
      
     Далі за допомогою середовища розробки або команди у терміналі javadoc -d docs Calculator.java можна створити документацію (Див. рис. 2.1).

Рисунок 2.1 — Приклад створеної документації
     
     ВИСНОВКИ
     Правильне оформлення та рефакторинг коду на Java мають ключове значення для читабельності, підтримуваності, продуктивності та надійності. Дотримання стандартів, таких як Google Java Style Guide, забезпечує єдиний стиль, зрозумілі імена, коректну структуру та послідовність розташування членів класу. Принципи рефакторингу, оптимізації та правильна обробка помилок гарантують, що код залишається чистим та ефективним з часом. Дотримання парадигм ООП та SOLID принципів робить архітектуру гнучкою та масштабованою. Комплексне тестування та документування підвищують якість та скорочують час адаптації нових розробників.
ВИКОРИСТАНІ ДЖЕРЕЛА 
1. Martin R. Robert C. Martin Clean Code Collection (Collection). Pearson Education, Limited.
2. Bloch, Joshua. Effective Java (3rd Edition). Pearson Education, Inc.
     

ДОДАТОК А
Посилання на відео
     https://youtu.be/aGfTwVpqblc
     Таймкоди:
     00:00 Вступ
     00:28 Стильові рекомендації
     01:08 Правила найменування
     02:26 Структура коду
     03:15 Принципи рефакторингу 
     04:03 Оптимізація продуктивності
     05:40 Обробка помилок
     06:58 Дотримання парадигм програмування
     07:50 Тестування коду
     08:30 Документування коду
     09:25 Висновки
     
     

ДОДАТОК Б
Слайди призентації

Рисунок Б.1 – Титульний слайд

Рисунок Б.2 – Слайд про вплив оформлення

Рисунок Б.3 – Слайд про стильові рекомендації

Рисунок Б.4 — Слайд про правила найменування 
 
Рисунок Б.5 — Слайд про структуру коду

Рисунок Б.5 — Слайд про принципи рефакторингу 

Рисунок Б.7 — Слайд про оптимізацію продуктивності

Рисунок Б.8 — Слайд про обробку помилок

Рисунок Б.9 — Слайд про парадигми програмування 

Рисунок Б.10 — Слайд про тестування коду

Рисунок Б.11 — Слайд про документування коду

Рисунок Б.12 — Висновки




