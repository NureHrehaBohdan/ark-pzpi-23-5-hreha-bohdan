МІНІСТЕРСТВО НАУКИ І ОСВІТИ УКРАЇНИ

ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ
УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ


ЗВІТ
До практичного завдання №2
з дисципліни «Аналіз та рефакторинг коду»













Виконав:                                                                          Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Грега Богдан                              Сокорчук Ігор Петрович










Харків 2025
     1 ІСТОРІЯ ЗМІН

№Дата Версія звіту Опис змін та виправлень 
1 10.12.2025 0.1 Створено розділи 2, 3.1, 3.2 
2 11.12.2025 0.2 Створено розділи 3.3, Висновки
     2 ЗАВДАННЯ
     
     Обрати три методи рефакторингу з книги Мартіна Фаулера «Refactoring: Improving the Design of Existing Code» і показати, як вони можуть покращити уже написаний вами код. Для кожного методу слід описати, яку проблему він допомагає вирішити, продемонструвати фрагмент коду до та після внесених змін і пояснити, які переваги дає застосований рефакторинг.
     
     3 ОПИС ВИКОНАНОЇ РОБОТИ
     
     У рамках цієї роботи було обрано три методи рефакторингу коду:
     1. Separate Domain from Presentation — відокремлення бізнес-логіки від логіки представлення
     2. Replace Inheritance with Delegation — заміна спадкування на композицію і делегування
     3. Push Down Method — переміщення методів з батьківського класу до дочірніх
     Застосування цих методів дозволяє покращити структуру програми, підвищити зрозумілість логіки та спростити подальше обслуговування коду.
     Рефакторинг загалом є процесом контрольованого вдосконалення внутрішньої структури програмного забезпечення без зміни його зовнішньої поведінки. Його мета полягає у створенні чистого, логічно послідовного та легкого для підтримки коду.
     
     3.1 Separate domain from presentation
     
     Метод Separate Domain from Presentation передбачає відокремлення бізнес-логіки (доменної моделі) від логіки представлення (UI). Доменна модель не залежить від способу її презентації, що дозволяє змінювати UI без змін бізнес-логіки.
     Коли логіка замовлення, обчислення суми та оновлення UI знаходяться в одному класі, виникають серйозні проблеми:
* Неможливо тестувати логіку без UI — тести залежать від графічних компонентів;
* Код залежить від платформи — логіка прив'язана до конкретного фреймворку (Swing, JavaFX);
* Дублювання при змінах UI — якщо потрібна веб-версія, доводиться переписувати все з нуля;
* Нарушення принципу єдиної відповідальності — один клас робить занадто багато.
     Початковий код наведено в додатку В.1. Клас OrderUI (додаток В.1) містить як бізнес-логіку, так і логіку представлення. Метод addItem додає товар до списку, а потім одразу оновлює текстову область. Метод calculateTotal обчислює суму, потім оновлює JLabel. Метод saveOrder змішує збереження з показом діалогу. Весь клас залежить від Swing компонентів.
     Після рефакторингу код був розділений на два класи (додаток В.2):
     Order — чиста бізнес-логіка без будь-яких посилань на UI. Методи просто додають товари, обчислюють суму та зберігають дані. Цей клас можна копіювати в будь-який проект.
     OrderUI — керує тільки представленням. Він містить об'єкт Order та делегує бізнес-операції до нього. UI логіка відокремлена від обчислень.
     Переваги:
     * Логіка тестується без UI — простіші, швидші тести;
* Переносимість — той самий Order працює з веб, мобільним, консолю;
     * Гнучкість — можна змінити UI без змін бізнес-логіки;
     * Читабельність — кожен клас має одну відповідальність;

     3.2 Replace inheritance with delegation
     
     Метод Replace Inheritance with Delegation заміняє спадкування (наслідування) на композицію та делегування. Замість того, щоб клас спадкував від іншого, він містить екземпляр цього класу та делегує йому методи.
     Спадкування здається природним, але на практиці створює проблеми:
* Жорстка архітектура — зв'язок між батьківським та дочірніми класами складно змінювати
* Обмежена гнучкість — не можна змінити поведінку під час виконання програми
* Проблема множинного спадкування — клас не може спадкувати від двох батьків одночасно
* Глибокі ієрархії — архітектура стає складною та важкою для розуміння
     Аналіз коду коду рефакторингу (додаток В.3) – клас Employee є батьківським. Manager та Developer спадкують від нього. Проблема в тому, що поведінка дочірніх класів кардинально відрізняється від батька. Метод calculateBonus перевизначається абсолютно по-іншому. Якщо потрібна нова роль (наприклад, Consultant), потрібно створити новий клас. Якщо потребується об'єднати Manager та Developer, спадкування це не дозволяє.
     Після рефакторингу (додаток 4.В) замість спадкування
* EmployeeRole — інтерфейс, який визначає контракт для ролей;
* ManagerRole, DeveloperRole — конкретні реалізації для кожної ролі;
* Employee — містить об'єкт EmployeeRole та делегує методи до нього. Також можна змінити роль під час виконання за допомогою setRole().
     Переваги:
* Динамічна поведінка — роль можна змінити в runtime
* Простота розширення — нова роль додається без змін існуючого коду
* Менша зв'язаність — залежність від інтерфейсу, не від реалізації
* Немає проблем множинного спадкування

     3.3 Push down method
     
     Метод Push Down Method передбачає переміщення методів з батьківського класу до дочірніх класів, якщо ці методи використовуються тільки деякими дочірніми класами. Термін «push down» (спустити вниз) буквально описує процес — метод рухається вниз по ієрархії від батька до дітей.
     Коли батьківський клас накопичує методи для конкретних типів:
* Перевантажений батьківський клас — містить непотрібні для всіх методи;
* Контрактні порушення — не всі дочірні класи повинні мати ці методи;
* Плутанина для користувачів — розробник не знає, який метод для якого типу;
* Помилки в runtime — неправильне викликання методу виявляється лише під час тестування.
     Код наведено в додатку В.5. Клас Shape містить методи get Area (для всіх фігур), getRadius(доречний для кола), getWidth/getHeight (доречний для прямокутника). Усі дочірні класи спадкують ці методи, хоча вони їм не потрібні. Розробник може викликати rectanle.getRadius(), що не має сенсу. Немає контролю на рівні типів.
     

     Після рефакторингу (додаток В.6):
* Shape містить тільки метод getArea спільний для всіх.
* Circle містить getRadius(), Rectangle — getWidth() та getWidtg(). Кожен клас має тільки свої методи.
* Тепер rectanle.getRadius() — це помилка компіляції, а не помилка runtime.
     Переваги:
* Чиста архітектура — батьківський клас є справжньою абстракцією
* Типобезпека — компілятор запобігає неправильному використанню
* Простота обслуговування — батьківський клас легче змінювати
     
     ВИСНОВКИ
     
     У процесі дослідження було розглянуто три важливі методи рефакторингу коду:
     1. Separate Domain from Presentation — розділення бізнес-логіки від представлення. Цей метод дозволяє тестувати логіку окремо, робить код переносимим та зменшує залежності між компонентами.
     2. Replace Inheritance with Delegation — заміна спадкування на композицію. Цей підхід робить архітектуру значно гнучкішою, дозволяє змінювати поведінку під час виконання та зменшує зв'язаність коду.
     3. Push Down Method — переміщення методів до дочірніх класів. Цей метод забезпечує чистоту батьківського класу, робить ієрархію зрозумілішою та спрощує обслуговування коду.
     Кожен з цих методів спрямований на підвищення якості програмного кода, його читабельності та гнучкості. 
     Використання таких підходів є показником професійності розробника та важливим кроком до підвищення якості програмного продукту.
     
     
     ВИКОРИСТАНІ ДЖЕРЕЛА
1. Martin, Robert C. Clean Code: A Handbook of Agile Software Craftsmanship. Pearson Education, Inc., 2008.
2. Refactoring Guru. Push Down Method. url: https://refactoring.guru/push-down-method 
     

ДОДАТОК А
Посилання на відео

Відеозапис: https://youtu.be/Bqd9eKz7MNo 
00:00 Вступ
00:40 Separate domain from presentation
01:02 Приклад коду до використання методу
01:56 Приклад коду після використання методу
02:32 Replace inheritance with delegation
02:55 Приклад коду до використання методу
03:52 Приклад коду після використання методу
04:26 Push down method
04:48 Приклад коду до використання методу
06:19 Приклад коду після використання методу




ДОДАТОК Б
Слайди призентації

Рисунок Б.1 – Титульний слайд


Рисунок Б.2 – Втупний слайд

Рисунок Б.3 – Слайд про Separate domain from presentation 


Рисунок Б.4 – Слайд з прикладом коду до використання методу

Рисунок Б.5 – Слайд з прикладом коду після використання методу


Рисунок Б.6 – Слайд про Replace Inheritance with delegation

Рисунок Б.7 – Слайд з прикладом коду до використання методу


Рисунок Б.9 – Слайд з прикладом коду після використання методу


Рисунок Б.9 – Слайд про Push down method


Рисунок Б.10 – Слайд з прикладом коду до використання методу


Рисунок Б.11 – Слайд з прикладом коду після використання методу


Рисунок Б.12 – Слайд з висновками

ДОДАТОК В
Програмний код
     В.1 Код для методу Separate Domain from Presentation (ДО)
      1   public class OrderUI {
      2       private JFrame frame;
      3       private JTextField customerNameField;
      4       private JTextArea orderDetailsArea;
      5       private List<OrderItem> items = new ArrayList<>();
      6       
      7       public void addItem(String name, double price, int quantity) {
      8           OrderItem item = new OrderItem(name, price, quantity);
      9           items.add(item);
      10          orderDetailsArea.append(name + " - " + (price * quantity) + "\n");
      11      }
      12      
      13      public double calculateTotal() {
      14          double total = 0;
      15          for (OrderItem item : items) {
      16              total += item.getPrice() * item.getQuantity();
      17          }
      18          JLabel totalLabel = new JLabel("Всього: " + total);
      19          frame.add(totalLabel);
      20          return total;
      21      }
      22      
      23      public void saveOrder() {
      24          String customerName = customerNameField.getText();
      25          JOptionPane.showMessageDialog(frame, 
      26              "Замовлення від " + customerName + " збережено");
      27      }
      28  } 
     В.2 Код для методу Separate Domain from Presentation (ПІСЛЯ)
      1   public class Order {
      2       private String customerName;
      3       private List<OrderItem> items = new ArrayList<>();
      4       
      5       public void addItem(OrderItem item) {
      6           items.add(item);
      7       }
      8       
      9       public double calculateTotal() {
      10          return items.stream()
      11              .mapToDouble(item -> item.getPrice() * item.getQuantity())
      12              .sum();
      13      }
      14      
      15      public void save() {
      16          System.out.println("Замовлення збережено для: " + customerName);
      17      }
      18      
      19      public String getCustomerName() { return customerName; }
      20      public void setCustomerName(String name) { this.customerName = name; }
      21  }
      22  
      23  public class OrderUI {
      24      private Order order = new Order();
      25      
      26      public void addItem(String name, double price, int quantity) {
      27          order.addItem(new OrderItem(name, price, quantity));
      28          orderDetailsArea.append(name + " - " + (price * quantity) + "\n");
      29      }
      30      
      31      public void displayTotal() {
      32          double total = order.calculateTotal();
      33          totalLabel.setText("Всього: " + total);
      34      }
      35  }
     
     В.3 Код для методу Replace Inheritance with Delegation (ДО)
      1   public class Employee {
      2       protected String name;
      3       protected double salary;
      4       
      5       public double calculateBonus() {
      6           return salary * 0.1;
      7       }
      8   }
      9   
      10  public class Manager extends Employee {
      11      private int teamSize;
      12      
      13      @Override
      14      public double calculateBonus() {
      15          return salary * 0.15 + teamSize * 100;
      16      }
      17  }
      18  
      19  public class Developer extends Employee {
      20      @Override
      21      public double calculateBonus() {
      22          return salary * 0.1;
      23      }
      24  }
     
     В.4 Код для методу Replace Inheritance with Delegation (ПІСЛЯ)
      1   public interface EmployeeRole {
      2       double calculateBonus(double salary);
      3   }
      4   
      5   public class ManagerRole implements EmployeeRole {
      6       private int teamSize;
      7       
      8       @Override
      9       public double calculateBonus(double salary) {
      10          return salary * 0.15 + teamSize * 100;
      11      }
      12  }
      13  
      14  public class DeveloperRole implements EmployeeRole {
      15      @Override
      16      public double calculateBonus(double salary) {
      17          return salary * 0.1;
      18      }
      19  }
      20  
      21  public class Employee {
      22      private String name;
      23      private double salary;
      24      private EmployeeRole role;
      25      
      26      public Employee(String name, double salary, EmployeeRole role) {
      27          this.name = name;
      28          this.salary = salary;
      29          this.role = role;
      30      }
      31      
      32      public double calculateBonus() {
      33          return role.calculateBonus(salary);
      34      }
      35      
      36      public void setRole(EmployeeRole newRole) {
      37          this.role = newRole;
      38      }
      39  }
     
     В.5 Код для методу Push Down Method (ДО)
      1   public abstract class Shape {
      2       protected String name;
      3       
      4       public abstract double getArea();
      5       
      6       public double getRadius() {
      7           System.out.println("Радіус");
      8           return 5.0;
      9       }
      10      
      11      public double getWidth() {
      12          System.out.println("Ширина");
      13          return 10.0;
      14      }
      15      
      16      public double getHeight() {
      17          System.out.println("Висота");
      18          return 15.0;
      19      }
      20  }
      21  
      22  public class Circle extends Shape {
      23      @Override
      24      public double getArea() {
      25          return Math.PI * getRadius() * getRadius();
      26      }
      27  }
      28  
      29  public class Rectangle extends Shape {
      30      @Override
      31      public double getArea() {
      32          return getWidth() * getHeight();
      33      }
      34  }
     
     В.6 Код для методу Push Down Method (ПІСЛЯ)
      1   public abstract class Shape {
      2       protected String name;
      3       
      4       public abstract double getArea();
      5   }
      6   
      7   public class Circle extends Shape {
      8       private double radius;
      9       
      10      public Circle(double radius) {
      11          this.radius = radius;
      12      }
      13      
      14      @Override
      15      public double getArea() {
      16          return Math.PI * radius * radius;
      17      }
      18      
      19      public double getRadius() {
      20          return radius;
      21      }
      22  }
      23  
      24  public class Rectangle extends Shape {
      25      private double width;
      26      private double height;
      27      
      28      public Rectangle(double width, double height) {
      29          this.width = width;
      30          this.height = height;
      31      }
      32      
      33      @Override
      34      public double getArea() {
      35          return width * height;
      36      }
      37      
      38      public double getWidth() {
      39          return width;
      40      }
      41      
      42      public double getHeight() {
      43          return height;
      44      }
      45  }

2


